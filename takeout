#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');
const { ask, isYes } = require('./src/lib/common');
const { validateUnpackedFolders } = require('./src/lib_validate_folders');
const { unpackMissingZips } = require('./src/lib_unpack_missing_zips');
const { moveFilesFlat } = require('./src/move_files_flat');
const { removeEmptyFolders } = require('./src/remove_empty_folders');
const { removeFilesByExtension } = require('./src/remove_files_by_extension');

const REPO_DIR = __dirname;
const DEFAULT_TARGET_DIR = path.join(REPO_DIR, 'test/src');
const DEFAULT_UNPACK_ROOT = path.join(REPO_DIR, 'test/dist/unpacked');
const DEFAULT_SRC_ROOT = DEFAULT_UNPACK_ROOT;
const DEFAULT_DST_ROOT = path.join(REPO_DIR, 'test/dist');

async function promptWithDefault(label, defaultValue) {
  const input = await ask(`${label} [${defaultValue}]: `);
  return input.trim() || defaultValue;
}

function zipStatus(targetDir, unpackRoot) {
  const all = fs.readdirSync(targetDir).filter((name) => name.toLowerCase().endsWith('.zip')).sort();
  const unpacked = [];
  const notUnpacked = [];

  for (const zip of all) {
    const base = zip.replace(/\.zip$/i, '');
    const unpackedDir = path.join(unpackRoot, base);
    if (fs.existsSync(unpackedDir) && fs.statSync(unpackedDir).isDirectory()) {
      unpacked.push(zip);
    } else {
      notUnpacked.push(zip);
    }
  }

  return { all, unpacked, notUnpacked };
}

async function cleanupEmptyFoldersFlow(rootDir) {
  while (true) {
    const summary = removeEmptyFolders(rootDir);
    if (!summary.remaining || summary.remaining === 0) {
      console.log('All folders are clean.');
      break;
    }

    if (summary.extensions.length > 0) {
      console.log(`Remaining file extensions: ${summary.extensions.join(',')}`);
    }

    const confirm = await ask('Remove files by extension and retry empty folders? [y/N]: ');
    if (!isYes(confirm)) {
      break;
    }

    const ext = (await ask('File extension to remove (e.g. .json): ')).trim();
    removeFilesByExtension(rootDir, ext, false);
  }
}

function startUiServer(portArg) {
  const serverPath = path.join(REPO_DIR, 'ui', 'server.js');
  if (!fs.existsSync(serverPath)) {
    throw new Error(`UI server not found: ${serverPath}`);
  }

  const args = [serverPath];
  const child = spawn(process.execPath, args, {
    cwd: REPO_DIR,
    stdio: 'inherit',
    env: {
      ...process.env,
      ...(portArg ? { PORT: String(portArg) } : {}),
    },
  });

  child.on('exit', (code) => {
    process.exit(code ?? 0);
  });
}

async function runCli(targetDirArg) {
  const targetDir = targetDirArg || DEFAULT_TARGET_DIR;
  const resolvedTarget = path.resolve(targetDir);

  if (!fs.existsSync(resolvedTarget) || !fs.statSync(resolvedTarget).isDirectory()) {
    console.error(`Directory not found: ${targetDir}`);
    process.exit(1);
  }

  process.chdir(resolvedTarget);

  while (true) {
    const { all, unpacked, notUnpacked } = zipStatus('.', DEFAULT_UNPACK_ROOT);

    if (all.length === 0) {
      console.log('No zip files found.');
      console.log('');
      console.log('Choose action:');
      console.log('--------------');
      console.log('  1) Move photos to <dst>/photos (flat)');
      console.log('  2) Move videos to <dst>/videos (flat)');
      console.log('  3) Remove empty folders');
      console.log('  4) Remove files by extension');
      console.log('  5) Validate unpacked folders contain data');
      console.log('  6) Refresh status');
      console.log('  7) Exit');
      console.log('');
      const choice = (await ask('Enter choice [1-7]: ')).trim();

      if (choice === '1') {
        const srcDir = await promptWithDefault('Source folder with unpacked takeout', DEFAULT_SRC_ROOT);
        const dstRoot = await promptWithDefault('Destination base folder', DEFAULT_DST_ROOT);
        moveFilesFlat(srcDir, `${dstRoot}/photos`, false, 'image');
      } else if (choice === '2') {
        const srcDir = await promptWithDefault('Source folder with unpacked takeout', DEFAULT_SRC_ROOT);
        const dstRoot = await promptWithDefault('Destination base folder', DEFAULT_DST_ROOT);
        moveFilesFlat(srcDir, `${dstRoot}/videos`, false, 'video');
      } else if (choice === '3') {
        const rootDir = await promptWithDefault('Root folder to clean empty directories', DEFAULT_SRC_ROOT);
        await cleanupEmptyFoldersFlow(rootDir);
      } else if (choice === '4') {
        const rootDir = await promptWithDefault('Root folder to clean empty directories', DEFAULT_SRC_ROOT);
        const ext = (await ask('File extension to remove (e.g. .json): ')).trim();
        removeFilesByExtension(rootDir, ext, false);
      } else if (choice === '5') {
        console.log('Nothing to validate: no zip files found.');
      } else if (choice === '6') {
        continue;
      } else if (choice === '7') {
        console.log('Exit.');
        process.exit(0);
      } else {
        console.log('Invalid choice.');
      }
      continue;
    }

    console.log('');
    console.log('Status:');
    console.log('-------');
    console.log(`${unpacked.length} out of ${all.length} unpacked`);
    if (notUnpacked.length === 0) {
      console.log('All unpacked');
    } else {
      console.log(`${notUnpacked.length} not unpacked`);
    }
    console.log('');

    if (notUnpacked.length === 0) {
      const autoValidate = await ask('All unpacked. Validate now? [y/N]: ');
      if (isYes(autoValidate)) {
        await validateUnpackedFolders(unpacked);
        continue;
      }
    }

    console.log('Choose action:');
    console.log('--------------');
    console.log('  1) Validate unpacked folders contain data');
    console.log('  2) Unpack missing zips');
    console.log('  3) Move photos to <dst>/photos (flat)');
    console.log('  4) Move videos to <dst>/videos (flat)');
    console.log('  5) Remove empty folders');
    console.log('  6) Remove files by extension');
    console.log('  7) Refresh status');
    console.log('  8) Exit');
    console.log('');

    const choice = (await ask('Enter choice [1-8]: ')).trim();

    if (choice === '1') {
      await validateUnpackedFolders(unpacked);
    } else if (choice === '2') {
      unpackMissingZips(notUnpacked, { outputRoot: DEFAULT_UNPACK_ROOT });
    } else if (choice === '3') {
      const srcDir = await promptWithDefault('Source folder with unpacked takeout', DEFAULT_SRC_ROOT);
      const dstRoot = await promptWithDefault('Destination base folder', DEFAULT_DST_ROOT);
      moveFilesFlat(srcDir, `${dstRoot}/photos`, false, 'image');
    } else if (choice === '4') {
      const srcDir = await promptWithDefault('Source folder with unpacked takeout', DEFAULT_SRC_ROOT);
      const dstRoot = await promptWithDefault('Destination base folder', DEFAULT_DST_ROOT);
      moveFilesFlat(srcDir, `${dstRoot}/videos`, false, 'video');
    } else if (choice === '5') {
      const rootDir = await promptWithDefault('Root folder to clean empty directories', DEFAULT_SRC_ROOT);
      await cleanupEmptyFoldersFlow(rootDir);
    } else if (choice === '6') {
      const rootDir = await promptWithDefault('Root folder to clean empty directories', DEFAULT_SRC_ROOT);
      const ext = (await ask('File extension to remove (e.g. .json): ')).trim();
      removeFilesByExtension(rootDir, ext, false);
    } else if (choice === '7') {
      continue;
    } else if (choice === '8') {
      console.log('Exit.');
      process.exit(0);
    } else {
      console.log('Invalid choice.');
    }
  }
}

async function main() {
  const mode = process.argv[2];

  if (!mode || mode === 'ui') {
    const portArg = process.argv[3];
    startUiServer(portArg);
    return;
  }

  if (mode === 'cli') {
    await runCli(process.argv[3]);
    return;
  }

  if (fs.existsSync(mode) && fs.statSync(mode).isDirectory()) {
    await runCli(mode);
    return;
  }

  console.log('Usage:');
  console.log('  ./takeout              # start web UI');
  console.log('  ./takeout ui [port]    # start web UI on optional port');
  console.log('  ./takeout cli [dir]    # start terminal mode');
  console.log('  ./takeout <dir>        # terminal mode (backward compatible)');
}

main().catch((err) => {
  console.error(err.message);
  process.exit(1);
});
